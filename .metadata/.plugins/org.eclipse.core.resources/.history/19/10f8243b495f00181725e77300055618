package binarytrees;

import stack.LinkedStack;

public class BinaryTree<T> 
{
	public BinaryNode<T> root;
	
	public BinaryTree()
	{
		this.root = null;
	}
	
	public BinaryTree(T[] prelist)
	{
		this.root = create(prelist,this.root);
	}
	
	private int i = 0;
	
	private BinaryNode<T> create(T[] prelist,BinaryNode<T> parent)
	{
		BinaryNode<T> p = null;
		if(i<prelist.length)
		{
			T elem = prelist[i];
			i++;
			if(elem!=null)
			{
				p = new BinaryNode<T>(elem,parent,null,null);
				p.left = create(prelist,p);
				p.right = create(prelist,p);
			}
		}
		return p;
	}
	
	public boolean isEmpty()
	{
		return this.root == null;
	}
	
	public BinaryNode<T> insert(BinaryNode<T> parent,T x,boolean leftChild)
	{
		if(x == null)
			return null;
		if(leftChild)
		{
			return parent.left = new BinaryNode<T>(x,parent,parent.left,null);
		}
		return parent.right = new BinaryNode<T>(x,parent,null,parent.right);
	}
	
	public void remove(BinaryNode<T> parent,boolean leftChild)
	{
		if(leftChild)
			parent.left = null;
		else
			parent.right = null;
	}
	
	public void clear()
	{
		this.root = null;
	}
	
	public void preorder()
	{
		preorder(this.root);
		System.out.println();
	}
	
	private void preorder(BinaryNode<T> p)
	{
		if(p!=null)
		{
			System.out.print(p.data.toString()+" ");
			preorder(p.left);
			preorder(p.right);
		}
		else
		{
			System.out.print("^ ");
		}
	}
	
	public void preorderTraverse()
	{
		System.out.print("先根次序遍历（非递归）： ");
		LinkedStack<BinaryNode<T>> stack = new LinkedStack<BinaryNode<T>>();
		BinaryNode<T> p = this.root;
		while(p!=null||!stack.isEmpty())
			if(p!=null)
			{
				System.out.print(p.data+" ");
				stack.push(p);
				p=p.left;
			}
			else
			{
				System.out.print("^ ");
				p=stack.pop();
				p=p.right;
			}
		System.out.println();
	}
	
	public void removeAllMatched(BinaryTree<T> pattern)
	{
		
	}
	
	
}
